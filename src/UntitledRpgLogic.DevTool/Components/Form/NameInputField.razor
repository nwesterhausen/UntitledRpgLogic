@*
    A reusable component for editing a Name object.
    It handles the immutable nature of the Name class by creating new instances on change.
*@
@using UntitledRpgLogic.Core.Classes
@using Microsoft.AspNetCore.Components.Forms
@inherits InputBase<Name>

<div class="card bg-base-300 shadow-inner p-4">
    <StringInputField Label="Singular Name" @bind-Value="Singular" />

    <div class="form-control">
        <label class="label cursor-pointer">
            <span class="label-text">Has Plural Name?</span>
            <input type="checkbox" @bind="HasPlural" class="toggle toggle-primary" />
        </label>
    </div>

    @if (HasPlural)
    {
        <StringInputField Label="Plural Name" @bind-Value="Plural" />
    }

    <div class="form-control">
        <label class="label cursor-pointer">
            <span class="label-text">Has Adjective?</span>
            <input type="checkbox" @bind="HasAdjective" class="toggle toggle-primary" />
        </label>
    </div>

    @if (HasAdjective)
    {
        <StringInputField Label="Adjective" @bind-Value="Adjective" />
    }
</div>


@code {
    // Local state for the input fields
    private string _singular = string.Empty;
    private string _plural = string.Empty;
    private string _adjective = string.Empty;

    // Local state for the toggles
    private bool _hasPlural;
    private bool _hasAdjective;

    /// <summary>
    /// When the component's parameters are set, update the local fields
    /// from the bound Name object.
    /// </summary>
    protected override void OnParametersSet()
    {
        _singular = CurrentValue?.Singular ?? string.Empty;
        _plural = CurrentValue?.Plural ?? string.Empty;
        _adjective = CurrentValue?.Adjective ?? string.Empty;

        // Set toggle states based on whether the optional fields have values
        _hasPlural = !string.IsNullOrWhiteSpace(_plural);
        _hasAdjective = !string.IsNullOrWhiteSpace(_adjective);
    }

    /// <summary>
    /// Updates the underlying Name object whenever a local field changes.
    /// This respects the immutability of the Name class.
    /// </summary>
    private void UpdateValue()
    {
        // Only update if the singular name is present
        if (string.IsNullOrWhiteSpace(_singular))
        {
            CurrentValue = null;
            return;
        }

        // Create a new Name object and update the component's value
        CurrentValue = new Name(
            _singular,
            _hasPlural ? _plural : null,
            _hasAdjective ? _adjective : null
        );
    }

    // Properties to handle changes in the local input fields
    private string Singular { get => _singular; set { _singular = value; UpdateValue(); } }
    private string Plural { get => _plural; set { _plural = value; UpdateValue(); } }
    private string Adjective { get => _adjective; set { _adjective = value; UpdateValue(); } }

    // Properties to handle changes in the toggles
    private bool HasPlural
    {
        get => _hasPlural;
        set
        {
            _hasPlural = value;
            if (!value) _plural = string.Empty; // Clear plural if toggle is off
            UpdateValue();
        }
    }

    private bool HasAdjective
    {
        get => _hasAdjective;
        set
        {
            _hasAdjective = value;
            if (!value) _adjective = string.Empty; // Clear adjective if toggle is off
            UpdateValue();
        }
    }

    /// <summary>
    /// This is required for InputBase, but our logic handles the conversion.
    /// </summary>
    protected override bool TryParseValueFromString(string? value, out Name result, out string validationErrorMessage)
    {
        // This component's binding is more complex than a simple string parse.
        // The UpdateValue method handles the creation of the Name object.
        // We can satisfy the contract by returning the current value.
        result = CurrentValue!;
        validationErrorMessage = string.Empty;
        return true;
    }
}
